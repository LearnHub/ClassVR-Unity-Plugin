// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: avn/connect/v1/ktx.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Avn.Connect.V1 {

  /// <summary>Holder for reflection information generated from avn/connect/v1/ktx.proto</summary>
  public static partial class KtxReflection {

    #region Descriptor
    /// <summary>File descriptor for avn/connect/v1/ktx.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static KtxReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chhhdm4vY29ubmVjdC92MS9rdHgucHJvdG8SDmF2bi5jb25uZWN0LnYxGiJh",
            "dm4vY29ubmVjdC92MS9hdXRob3JpemF0aW9uLnByb3RvImwKDFRvS3R4UmVx",
            "dWVzdBIrCgRhdXRoGAEgASgLMh0uYXZuLmNvbm5lY3QudjEuQXV0aG9yaXph",
            "dGlvbhIvCgZwYXJhbXMYAiABKAsyHy5hdm4uY29ubmVjdC52MS5Ub0t0eFBh",
            "cmFtZXRlcnMizQQKD1RvS3R4UGFyYW1ldGVycxIMCgR1cmxzGAEgAygJEhQK",
            "B2N1YmVtYXAYAiABKAhIAIgBARIWCglnZW5taXBtYXAYAyABKAhIAYgBARIY",
            "Cgt0YXJnZXRfdHlwZRgEIAEoCUgCiAEBEg8KAnQyGAUgASgISAOIAQESEQoE",
            "YmNtcBgGIAEoCEgEiAEBEhMKBmNsZXZlbBgHIAEoBUgFiAEBEhMKBnFsZXZl",
            "bBgIIAEoBUgGiAEBEhsKCm5vcm1hbF9tYXAYCSABKAhCAhgBSAeIAQESEgoF",
            "dWFzdGMYCiABKAVICIgBARIRCgR6Y21wGAsgASgFSAmIAQESGAoLYXNzaWdu",
            "X29ldGYYDCABKAlICogBARIdChBhc3NpZ25fcHJpbWFyaWVzGA0gASgJSAuI",
            "AQESGQoMY29udmVydF9vZXRmGA4gASgJSAyIAQESGAoLbm9ybWFsX21vZGUY",
            "DyABKAhIDYgBARIaCg1pbnB1dF9zd2l6emxlGBAgASgJSA6IAQFCCgoIX2N1",
            "YmVtYXBCDAoKX2dlbm1pcG1hcEIOCgxfdGFyZ2V0X3R5cGVCBQoDX3QyQgcK",
            "BV9iY21wQgkKB19jbGV2ZWxCCQoHX3FsZXZlbEINCgtfbm9ybWFsX21hcEII",
            "CgZfdWFzdGNCBwoFX3pjbXBCDgoMX2Fzc2lnbl9vZXRmQhMKEV9hc3NpZ25f",
            "cHJpbWFyaWVzQg8KDV9jb252ZXJ0X29ldGZCDgoMX25vcm1hbF9tb2RlQhAK",
            "Dl9pbnB1dF9zd2l6emxlIhwKDVRvS3R4UmVzcG9uc2USCwoDdXJsGAEgASgJ",
            "MlIKCkt0eFNlcnZpY2USRAoFVG9LdHgSHC5hdm4uY29ubmVjdC52MS5Ub0t0",
            "eFJlcXVlc3QaHS5hdm4uY29ubmVjdC52MS5Ub0t0eFJlc3BvbnNlYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Avn.Connect.V1.AuthorizationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Avn.Connect.V1.ToKtxRequest), global::Avn.Connect.V1.ToKtxRequest.Parser, new[]{ "Auth", "Params" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Avn.Connect.V1.ToKtxParameters), global::Avn.Connect.V1.ToKtxParameters.Parser, new[]{ "Urls", "Cubemap", "Genmipmap", "TargetType", "T2", "Bcmp", "Clevel", "Qlevel", "NormalMap", "Uastc", "Zcmp", "AssignOetf", "AssignPrimaries", "ConvertOetf", "NormalMode", "InputSwizzle" }, new[]{ "Cubemap", "Genmipmap", "TargetType", "T2", "Bcmp", "Clevel", "Qlevel", "NormalMap", "Uastc", "Zcmp", "AssignOetf", "AssignPrimaries", "ConvertOetf", "NormalMode", "InputSwizzle" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Avn.Connect.V1.ToKtxResponse), global::Avn.Connect.V1.ToKtxResponse.Parser, new[]{ "Url" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Supports a subset of the useful parameters for toktx
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ToKtxRequest : pb::IMessage<ToKtxRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ToKtxRequest> _parser = new pb::MessageParser<ToKtxRequest>(() => new ToKtxRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ToKtxRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Avn.Connect.V1.KtxReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxRequest(ToKtxRequest other) : this() {
      auth_ = other.auth_ != null ? other.auth_.Clone() : null;
      params_ = other.params_ != null ? other.params_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxRequest Clone() {
      return new ToKtxRequest(this);
    }

    /// <summary>Field number for the "auth" field.</summary>
    public const int AuthFieldNumber = 1;
    private global::Avn.Connect.V1.Authorization auth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Avn.Connect.V1.Authorization Auth {
      get { return auth_; }
      set {
        auth_ = value;
      }
    }

    /// <summary>Field number for the "params" field.</summary>
    public const int ParamsFieldNumber = 2;
    private global::Avn.Connect.V1.ToKtxParameters params_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Avn.Connect.V1.ToKtxParameters Params {
      get { return params_; }
      set {
        params_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ToKtxRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ToKtxRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Auth, other.Auth)) return false;
      if (!object.Equals(Params, other.Params)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (auth_ != null) hash ^= Auth.GetHashCode();
      if (params_ != null) hash ^= Params.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (auth_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Auth);
      }
      if (params_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Params);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (auth_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Auth);
      }
      if (params_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Params);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (auth_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Auth);
      }
      if (params_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Params);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ToKtxRequest other) {
      if (other == null) {
        return;
      }
      if (other.auth_ != null) {
        if (auth_ == null) {
          Auth = new global::Avn.Connect.V1.Authorization();
        }
        Auth.MergeFrom(other.Auth);
      }
      if (other.params_ != null) {
        if (params_ == null) {
          Params = new global::Avn.Connect.V1.ToKtxParameters();
        }
        Params.MergeFrom(other.Params);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (auth_ == null) {
              Auth = new global::Avn.Connect.V1.Authorization();
            }
            input.ReadMessage(Auth);
            break;
          }
          case 18: {
            if (params_ == null) {
              Params = new global::Avn.Connect.V1.ToKtxParameters();
            }
            input.ReadMessage(Params);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (auth_ == null) {
              Auth = new global::Avn.Connect.V1.Authorization();
            }
            input.ReadMessage(Auth);
            break;
          }
          case 18: {
            if (params_ == null) {
              Params = new global::Avn.Connect.V1.ToKtxParameters();
            }
            input.ReadMessage(Params);
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ToKtxParameters : pb::IMessage<ToKtxParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ToKtxParameters> _parser = new pb::MessageParser<ToKtxParameters>(() => new ToKtxParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ToKtxParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Avn.Connect.V1.KtxReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxParameters(ToKtxParameters other) : this() {
      _hasBits0 = other._hasBits0;
      urls_ = other.urls_.Clone();
      cubemap_ = other.cubemap_;
      genmipmap_ = other.genmipmap_;
      targetType_ = other.targetType_;
      t2_ = other.t2_;
      bcmp_ = other.bcmp_;
      clevel_ = other.clevel_;
      qlevel_ = other.qlevel_;
      normalMap_ = other.normalMap_;
      uastc_ = other.uastc_;
      zcmp_ = other.zcmp_;
      assignOetf_ = other.assignOetf_;
      assignPrimaries_ = other.assignPrimaries_;
      convertOetf_ = other.convertOetf_;
      normalMode_ = other.normalMode_;
      inputSwizzle_ = other.inputSwizzle_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxParameters Clone() {
      return new ToKtxParameters(this);
    }

    /// <summary>Field number for the "urls" field.</summary>
    public const int UrlsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_urls_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> urls_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Input files
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Urls {
      get { return urls_; }
    }

    /// <summary>Field number for the "cubemap" field.</summary>
    public const int CubemapFieldNumber = 2;
    private readonly static bool CubemapDefaultValue = false;

    private bool cubemap_;
    /// <summary>
    /// --cubemap    KTX file is for a cubemap. At least 6 &lt;infile>s must be provided,
    ///              more if --mipmap is also specified. Provide the images in the
    ///              order +X, -X, +Y, -Y, +Z, -Z where the arrangement is a
    ///              left-handed coordinate system with +Y up. So if you're facing +Z,
    ///              -X will be on your left and +X on your right. If --layers > 1
    ///              is specified, provide the faces for layer 0 first then for
    ///              layer 1, etc. Images must have an upper left origin so
    ///              --lower_left_maps_to_s0t0 is ignored with this option.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Cubemap {
      get { if ((_hasBits0 & 1) != 0) { return cubemap_; } else { return CubemapDefaultValue; } }
      set {
        _hasBits0 |= 1;
        cubemap_ = value;
      }
    }
    /// <summary>Gets whether the "cubemap" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCubemap {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "cubemap" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCubemap() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "genmipmap" field.</summary>
    public const int GenmipmapFieldNumber = 3;
    private readonly static bool GenmipmapDefaultValue = false;

    private bool genmipmap_;
    /// <summary>
    /// --genmipmap  Causes mipmaps to be generated for each input file. This option
    ///              is mutually exclusive with --automipmap and --mipmap. When set
    ///              the following mipmap-generation related options become valid,
    ///              otherwise they are ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Genmipmap {
      get { if ((_hasBits0 & 2) != 0) { return genmipmap_; } else { return GenmipmapDefaultValue; } }
      set {
        _hasBits0 |= 2;
        genmipmap_ = value;
      }
    }
    /// <summary>Gets whether the "genmipmap" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGenmipmap {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "genmipmap" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGenmipmap() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "target_type" field.</summary>
    public const int TargetTypeFieldNumber = 4;
    private readonly static string TargetTypeDefaultValue = "";

    private string targetType_;
    /// <summary>
    /// --target_type &lt;type>
    ///              Specify the number of components in the created texture. type is
    ///              one of the following strings: @c R, @c RG, @c RGB or @c RGBA.
    ///              Excess input components will be dropped. Output components with
    ///              no mapping from the input will be set to 0 or, if the alpha
    ///              component, 1.0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TargetType {
      get { return targetType_ ?? TargetTypeDefaultValue; }
      set {
        targetType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "target_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTargetType {
      get { return targetType_ != null; }
    }
    /// <summary>Clears the value of the "target_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTargetType() {
      targetType_ = null;
    }

    /// <summary>Field number for the "t2" field.</summary>
    public const int T2FieldNumber = 5;
    private readonly static bool T2DefaultValue = false;

    private bool t2_;
    /// <summary>
    /// --t2         Output in KTX2 format. Default is KTX.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool T2 {
      get { if ((_hasBits0 & 4) != 0) { return t2_; } else { return T2DefaultValue; } }
      set {
        _hasBits0 |= 4;
        t2_ = value;
      }
    }
    /// <summary>Gets whether the "t2" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasT2 {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "t2" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearT2() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "bcmp" field.</summary>
    public const int BcmpFieldNumber = 6;
    private readonly static bool BcmpDefaultValue = false;

    private bool bcmp_;
    /// <summary>
    /// --bcmp       Supercompress the image data with ETC1S / BasisLZ. Implies --t2.
    ///              RED images will become RGB with RED in each component. RG images
    ///              will have R in the RGB part and G in the alpha part of the
    ///              compressed texture. When set, the following BasisLZ-related
    ///              options become valid, otherwise they are ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Bcmp {
      get { if ((_hasBits0 & 8) != 0) { return bcmp_; } else { return BcmpDefaultValue; } }
      set {
        _hasBits0 |= 8;
        bcmp_ = value;
      }
    }
    /// <summary>Gets whether the "bcmp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBcmp {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "bcmp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBcmp() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "clevel" field.</summary>
    public const int ClevelFieldNumber = 7;
    private readonly static int ClevelDefaultValue = 0;

    private int clevel_;
    /// <summary>
    ///     --clevel &lt;level>
    ///              ETC1S / BasisLZ compression level, an encoding speed vs. quality
    ///              tradeoff. Range is [0,5], default is 1. Higher values are slower,
    ///              but give higher quality.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Clevel {
      get { if ((_hasBits0 & 16) != 0) { return clevel_; } else { return ClevelDefaultValue; } }
      set {
        _hasBits0 |= 16;
        clevel_ = value;
      }
    }
    /// <summary>Gets whether the "clevel" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasClevel {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "clevel" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClevel() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "qlevel" field.</summary>
    public const int QlevelFieldNumber = 8;
    private readonly static int QlevelDefaultValue = 0;

    private int qlevel_;
    /// <summary>
    ///     --qlevel &lt;level>
    ///              ETC1S / BasisLZ quality level. Range is [1,255]. Lower gives
    ///              better compression/lower quality/faster. Higher gives less
    ///              compression/higher quality/slower. --qlevel automatically
    ///              determines values for --max_endpoints, --max-selectors,
    ///              --endpoint_rdo_threshold and --selector_rdo_threshold for the
    ///              target quality level. Setting these options overrides the values
    ///              determined by -qlevel which defaults to 128 if neither it nor
    ///              both of --max_endpoints and --max_selectors have been set.
    ///
    ///              Note that both of --max_endpoints and --max_selectors
    ///              must be set for them to have any effect. If all three options
    ///              are set, a warning will be issued that --qlevel will be ignored.
    ///
    ///              Note also that --qlevel will only determine values for
    ///              --endpoint_rdo_threshold and --selector_rdo_threshold when
    ///              its value exceeds 128, otherwise their defaults will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Qlevel {
      get { if ((_hasBits0 & 32) != 0) { return qlevel_; } else { return QlevelDefaultValue; } }
      set {
        _hasBits0 |= 32;
        qlevel_ = value;
      }
    }
    /// <summary>Gets whether the "qlevel" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQlevel {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "qlevel" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQlevel() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "normal_map" field.</summary>
    public const int NormalMapFieldNumber = 9;
    private readonly static bool NormalMapDefaultValue = false;

    private bool normalMap_;
    /// <summary>
    /// DEPRECATED: https://github.com/KhronosGroup/KTX-Software/discussions/601
    ///     --normal_map
    ///              Tunes codec parameters for better quality on normal maps (no
    ///              selector RDO, no endpoint RDO). Only valid for linear textures.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool NormalMap {
      get { if ((_hasBits0 & 64) != 0) { return normalMap_; } else { return NormalMapDefaultValue; } }
      set {
        _hasBits0 |= 64;
        normalMap_ = value;
      }
    }
    /// <summary>Gets whether the "normal_map" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNormalMap {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "normal_map" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNormalMap() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "uastc" field.</summary>
    public const int UastcFieldNumber = 10;
    private readonly static int UastcDefaultValue = 0;

    private int uastc_;
    /// <summary>
    /// --uastc [&lt;level>]
    ///              Create a texture in high-quality transcodable UASTC format.
    ///              Implies --t2. The optional parameter &lt;level> selects a speed
    ///              vs quality tradeoff as shown in the following table:
    ///
    ///                Level |  Speed    | Quality
    ///                ----- | -------   | -------
    ///                  0   |  Fastest  | 43.45dB
    ///                  1   |  Faster   | 46.49dB
    ///                  2   |  Default  | 47.47dB
    ///                  3   |  Slower   | 48.01dB
    ///                  4   | Very slow | 48.24dB
    ///
    ///              You are strongly encouraged to also specify --zcmp to losslessly
    ///              compress the UASTC data. This and any LZ-style compression can
    ///              be made more effective by conditioning the UASTC texture data
    ///              using the Rate Distortion Optimization (RDO) post-process stage.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Uastc {
      get { if ((_hasBits0 & 128) != 0) { return uastc_; } else { return UastcDefaultValue; } }
      set {
        _hasBits0 |= 128;
        uastc_ = value;
      }
    }
    /// <summary>Gets whether the "uastc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUastc {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "uastc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUastc() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "zcmp" field.</summary>
    public const int ZcmpFieldNumber = 11;
    private readonly static int ZcmpDefaultValue = 0;

    private int zcmp_;
    /// <summary>
    /// --zcmp [&lt;compressionLevel>]
    ///              Supercompress the data with Zstandard. Implies --t2. Can be used
    ///              with data in any format except ETC1S / BasisLZ (--bcmp). Most
    ///              effective with RDO-conditioned UASTC or uncompressed formats. The
    ///              optional compressionLevel range is 1 - 22 and the default is 3.
    ///              Lower values=faster but give less compression. Values above 20
    ///              should be used with caution as they require more memory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Zcmp {
      get { if ((_hasBits0 & 256) != 0) { return zcmp_; } else { return ZcmpDefaultValue; } }
      set {
        _hasBits0 |= 256;
        zcmp_ = value;
      }
    }
    /// <summary>Gets whether the "zcmp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasZcmp {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "zcmp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearZcmp() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "assign_oetf" field.</summary>
    public const int AssignOetfFieldNumber = 12;
    private readonly static string AssignOetfDefaultValue = "";

    private string assignOetf_;
    /// <summary>
    /// --assign_oetf &lt;linear|srgb>
    ///              Force the created texture to have the specified transfer
    ///              function. If this is specified, implicit or explicit color space
    ///              information from the input file(s) will be ignored and no color
    ///              transformation will be performed. USE WITH CAUTION preferably
    ///              only when you know the file format information is wrong.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AssignOetf {
      get { return assignOetf_ ?? AssignOetfDefaultValue; }
      set {
        assignOetf_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "assign_oetf" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAssignOetf {
      get { return assignOetf_ != null; }
    }
    /// <summary>Clears the value of the "assign_oetf" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAssignOetf() {
      assignOetf_ = null;
    }

    /// <summary>Field number for the "assign_primaries" field.</summary>
    public const int AssignPrimariesFieldNumber = 13;
    private readonly static string AssignPrimariesDefaultValue = "";

    private string assignPrimaries_;
    /// <summary>
    /// --assign_primaries &lt;bt709|none|srgb>
    ///              Force the created texture to have the specified primaries. If
    ///              this is specified, implicit or explicit color space information
    ///              from the input file(s) will be ignored and no color
    ///              transformation will be performed. USE WITH CAUTION preferably
    ///              only when you know the file format information is wrong.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AssignPrimaries {
      get { return assignPrimaries_ ?? AssignPrimariesDefaultValue; }
      set {
        assignPrimaries_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "assign_primaries" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAssignPrimaries {
      get { return assignPrimaries_ != null; }
    }
    /// <summary>Clears the value of the "assign_primaries" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAssignPrimaries() {
      assignPrimaries_ = null;
    }

    /// <summary>Field number for the "convert_oetf" field.</summary>
    public const int ConvertOetfFieldNumber = 14;
    private readonly static string ConvertOetfDefaultValue = "";

    private string convertOetf_;
    /// <summary>
    /// --convert_oetf &lt;linear|srgb>
    ///              Convert the input images to the specified transfer function, if
    ///              the current transfer function is different. If both this and
    ///              --assign_oetf are specified, conversion will be performed from
    ///              the assigned transfer function to the transfer function specified
    ///              by this option, if different.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ConvertOetf {
      get { return convertOetf_ ?? ConvertOetfDefaultValue; }
      set {
        convertOetf_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "convert_oetf" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConvertOetf {
      get { return convertOetf_ != null; }
    }
    /// <summary>Clears the value of the "convert_oetf" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConvertOetf() {
      convertOetf_ = null;
    }

    /// <summary>Field number for the "normal_mode" field.</summary>
    public const int NormalModeFieldNumber = 15;
    private readonly static bool NormalModeDefaultValue = false;

    private bool normalMode_;
    /// <summary>
    ///   You can prevent conversion of the normal map to two components
    ///   by specifying '--input_swizzle rgb1'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool NormalMode {
      get { if ((_hasBits0 & 512) != 0) { return normalMode_; } else { return NormalModeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        normalMode_ = value;
      }
    }
    /// <summary>Gets whether the "normal_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNormalMode {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "normal_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNormalMode() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "input_swizzle" field.</summary>
    public const int InputSwizzleFieldNumber = 16;
    private readonly static string InputSwizzleDefaultValue = "";

    private string inputSwizzle_;
    /// <summary>
    /// --input_swizzle &lt;swizzle>
    ///              Swizzle the input components according to swizzle which is an
    ///              alhpanumeric sequence matching the regular expression
    ///              ^[rgba01]{4}$.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string InputSwizzle {
      get { return inputSwizzle_ ?? InputSwizzleDefaultValue; }
      set {
        inputSwizzle_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "input_swizzle" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInputSwizzle {
      get { return inputSwizzle_ != null; }
    }
    /// <summary>Clears the value of the "input_swizzle" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInputSwizzle() {
      inputSwizzle_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ToKtxParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ToKtxParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!urls_.Equals(other.urls_)) return false;
      if (Cubemap != other.Cubemap) return false;
      if (Genmipmap != other.Genmipmap) return false;
      if (TargetType != other.TargetType) return false;
      if (T2 != other.T2) return false;
      if (Bcmp != other.Bcmp) return false;
      if (Clevel != other.Clevel) return false;
      if (Qlevel != other.Qlevel) return false;
      if (NormalMap != other.NormalMap) return false;
      if (Uastc != other.Uastc) return false;
      if (Zcmp != other.Zcmp) return false;
      if (AssignOetf != other.AssignOetf) return false;
      if (AssignPrimaries != other.AssignPrimaries) return false;
      if (ConvertOetf != other.ConvertOetf) return false;
      if (NormalMode != other.NormalMode) return false;
      if (InputSwizzle != other.InputSwizzle) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= urls_.GetHashCode();
      if (HasCubemap) hash ^= Cubemap.GetHashCode();
      if (HasGenmipmap) hash ^= Genmipmap.GetHashCode();
      if (HasTargetType) hash ^= TargetType.GetHashCode();
      if (HasT2) hash ^= T2.GetHashCode();
      if (HasBcmp) hash ^= Bcmp.GetHashCode();
      if (HasClevel) hash ^= Clevel.GetHashCode();
      if (HasQlevel) hash ^= Qlevel.GetHashCode();
      if (HasNormalMap) hash ^= NormalMap.GetHashCode();
      if (HasUastc) hash ^= Uastc.GetHashCode();
      if (HasZcmp) hash ^= Zcmp.GetHashCode();
      if (HasAssignOetf) hash ^= AssignOetf.GetHashCode();
      if (HasAssignPrimaries) hash ^= AssignPrimaries.GetHashCode();
      if (HasConvertOetf) hash ^= ConvertOetf.GetHashCode();
      if (HasNormalMode) hash ^= NormalMode.GetHashCode();
      if (HasInputSwizzle) hash ^= InputSwizzle.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      urls_.WriteTo(output, _repeated_urls_codec);
      if (HasCubemap) {
        output.WriteRawTag(16);
        output.WriteBool(Cubemap);
      }
      if (HasGenmipmap) {
        output.WriteRawTag(24);
        output.WriteBool(Genmipmap);
      }
      if (HasTargetType) {
        output.WriteRawTag(34);
        output.WriteString(TargetType);
      }
      if (HasT2) {
        output.WriteRawTag(40);
        output.WriteBool(T2);
      }
      if (HasBcmp) {
        output.WriteRawTag(48);
        output.WriteBool(Bcmp);
      }
      if (HasClevel) {
        output.WriteRawTag(56);
        output.WriteInt32(Clevel);
      }
      if (HasQlevel) {
        output.WriteRawTag(64);
        output.WriteInt32(Qlevel);
      }
      if (HasNormalMap) {
        output.WriteRawTag(72);
        output.WriteBool(NormalMap);
      }
      if (HasUastc) {
        output.WriteRawTag(80);
        output.WriteInt32(Uastc);
      }
      if (HasZcmp) {
        output.WriteRawTag(88);
        output.WriteInt32(Zcmp);
      }
      if (HasAssignOetf) {
        output.WriteRawTag(98);
        output.WriteString(AssignOetf);
      }
      if (HasAssignPrimaries) {
        output.WriteRawTag(106);
        output.WriteString(AssignPrimaries);
      }
      if (HasConvertOetf) {
        output.WriteRawTag(114);
        output.WriteString(ConvertOetf);
      }
      if (HasNormalMode) {
        output.WriteRawTag(120);
        output.WriteBool(NormalMode);
      }
      if (HasInputSwizzle) {
        output.WriteRawTag(130, 1);
        output.WriteString(InputSwizzle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      urls_.WriteTo(ref output, _repeated_urls_codec);
      if (HasCubemap) {
        output.WriteRawTag(16);
        output.WriteBool(Cubemap);
      }
      if (HasGenmipmap) {
        output.WriteRawTag(24);
        output.WriteBool(Genmipmap);
      }
      if (HasTargetType) {
        output.WriteRawTag(34);
        output.WriteString(TargetType);
      }
      if (HasT2) {
        output.WriteRawTag(40);
        output.WriteBool(T2);
      }
      if (HasBcmp) {
        output.WriteRawTag(48);
        output.WriteBool(Bcmp);
      }
      if (HasClevel) {
        output.WriteRawTag(56);
        output.WriteInt32(Clevel);
      }
      if (HasQlevel) {
        output.WriteRawTag(64);
        output.WriteInt32(Qlevel);
      }
      if (HasNormalMap) {
        output.WriteRawTag(72);
        output.WriteBool(NormalMap);
      }
      if (HasUastc) {
        output.WriteRawTag(80);
        output.WriteInt32(Uastc);
      }
      if (HasZcmp) {
        output.WriteRawTag(88);
        output.WriteInt32(Zcmp);
      }
      if (HasAssignOetf) {
        output.WriteRawTag(98);
        output.WriteString(AssignOetf);
      }
      if (HasAssignPrimaries) {
        output.WriteRawTag(106);
        output.WriteString(AssignPrimaries);
      }
      if (HasConvertOetf) {
        output.WriteRawTag(114);
        output.WriteString(ConvertOetf);
      }
      if (HasNormalMode) {
        output.WriteRawTag(120);
        output.WriteBool(NormalMode);
      }
      if (HasInputSwizzle) {
        output.WriteRawTag(130, 1);
        output.WriteString(InputSwizzle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += urls_.CalculateSize(_repeated_urls_codec);
      if (HasCubemap) {
        size += 1 + 1;
      }
      if (HasGenmipmap) {
        size += 1 + 1;
      }
      if (HasTargetType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TargetType);
      }
      if (HasT2) {
        size += 1 + 1;
      }
      if (HasBcmp) {
        size += 1 + 1;
      }
      if (HasClevel) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Clevel);
      }
      if (HasQlevel) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Qlevel);
      }
      if (HasNormalMap) {
        size += 1 + 1;
      }
      if (HasUastc) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Uastc);
      }
      if (HasZcmp) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Zcmp);
      }
      if (HasAssignOetf) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AssignOetf);
      }
      if (HasAssignPrimaries) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AssignPrimaries);
      }
      if (HasConvertOetf) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ConvertOetf);
      }
      if (HasNormalMode) {
        size += 1 + 1;
      }
      if (HasInputSwizzle) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(InputSwizzle);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ToKtxParameters other) {
      if (other == null) {
        return;
      }
      urls_.Add(other.urls_);
      if (other.HasCubemap) {
        Cubemap = other.Cubemap;
      }
      if (other.HasGenmipmap) {
        Genmipmap = other.Genmipmap;
      }
      if (other.HasTargetType) {
        TargetType = other.TargetType;
      }
      if (other.HasT2) {
        T2 = other.T2;
      }
      if (other.HasBcmp) {
        Bcmp = other.Bcmp;
      }
      if (other.HasClevel) {
        Clevel = other.Clevel;
      }
      if (other.HasQlevel) {
        Qlevel = other.Qlevel;
      }
      if (other.HasNormalMap) {
        NormalMap = other.NormalMap;
      }
      if (other.HasUastc) {
        Uastc = other.Uastc;
      }
      if (other.HasZcmp) {
        Zcmp = other.Zcmp;
      }
      if (other.HasAssignOetf) {
        AssignOetf = other.AssignOetf;
      }
      if (other.HasAssignPrimaries) {
        AssignPrimaries = other.AssignPrimaries;
      }
      if (other.HasConvertOetf) {
        ConvertOetf = other.ConvertOetf;
      }
      if (other.HasNormalMode) {
        NormalMode = other.NormalMode;
      }
      if (other.HasInputSwizzle) {
        InputSwizzle = other.InputSwizzle;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            urls_.AddEntriesFrom(input, _repeated_urls_codec);
            break;
          }
          case 16: {
            Cubemap = input.ReadBool();
            break;
          }
          case 24: {
            Genmipmap = input.ReadBool();
            break;
          }
          case 34: {
            TargetType = input.ReadString();
            break;
          }
          case 40: {
            T2 = input.ReadBool();
            break;
          }
          case 48: {
            Bcmp = input.ReadBool();
            break;
          }
          case 56: {
            Clevel = input.ReadInt32();
            break;
          }
          case 64: {
            Qlevel = input.ReadInt32();
            break;
          }
          case 72: {
            NormalMap = input.ReadBool();
            break;
          }
          case 80: {
            Uastc = input.ReadInt32();
            break;
          }
          case 88: {
            Zcmp = input.ReadInt32();
            break;
          }
          case 98: {
            AssignOetf = input.ReadString();
            break;
          }
          case 106: {
            AssignPrimaries = input.ReadString();
            break;
          }
          case 114: {
            ConvertOetf = input.ReadString();
            break;
          }
          case 120: {
            NormalMode = input.ReadBool();
            break;
          }
          case 130: {
            InputSwizzle = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            urls_.AddEntriesFrom(ref input, _repeated_urls_codec);
            break;
          }
          case 16: {
            Cubemap = input.ReadBool();
            break;
          }
          case 24: {
            Genmipmap = input.ReadBool();
            break;
          }
          case 34: {
            TargetType = input.ReadString();
            break;
          }
          case 40: {
            T2 = input.ReadBool();
            break;
          }
          case 48: {
            Bcmp = input.ReadBool();
            break;
          }
          case 56: {
            Clevel = input.ReadInt32();
            break;
          }
          case 64: {
            Qlevel = input.ReadInt32();
            break;
          }
          case 72: {
            NormalMap = input.ReadBool();
            break;
          }
          case 80: {
            Uastc = input.ReadInt32();
            break;
          }
          case 88: {
            Zcmp = input.ReadInt32();
            break;
          }
          case 98: {
            AssignOetf = input.ReadString();
            break;
          }
          case 106: {
            AssignPrimaries = input.ReadString();
            break;
          }
          case 114: {
            ConvertOetf = input.ReadString();
            break;
          }
          case 120: {
            NormalMode = input.ReadBool();
            break;
          }
          case 130: {
            InputSwizzle = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ToKtxResponse : pb::IMessage<ToKtxResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ToKtxResponse> _parser = new pb::MessageParser<ToKtxResponse>(() => new ToKtxResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ToKtxResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Avn.Connect.V1.KtxReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxResponse(ToKtxResponse other) : this() {
      url_ = other.url_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToKtxResponse Clone() {
      return new ToKtxResponse(this);
    }

    /// <summary>Field number for the "url" field.</summary>
    public const int UrlFieldNumber = 1;
    private string url_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Url {
      get { return url_; }
      set {
        url_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ToKtxResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ToKtxResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Url != other.Url) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Url.Length != 0) hash ^= Url.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Url.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Url);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Url.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Url);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Url.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Url);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ToKtxResponse other) {
      if (other == null) {
        return;
      }
      if (other.Url.Length != 0) {
        Url = other.Url;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Url = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Url = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
